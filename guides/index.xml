<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Guides on HomotopyContinuation.jl</title>
    <link>/guides/</link>
    <description>Recent content in Guides on HomotopyContinuation.jl</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 15 Apr 2019 18:56:55 +0100</lastBuildDate>
    
	<atom:link href="/guides/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Installing HomotopyContinuation.jl</title>
      <link>/guides/installation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/installation/</guid>
      <description>Requirements In order to use HomotopyContinuation.jl you need to have at least Julia 1.4 installed. If this is not the case you can download it at julialang.org. Please see the platform specific instructions if you have trouble installing Julia.
Installation HomotopyContinuation.jl is available through the Julia package manager. You can enter it by pressing ] in the REPL and then typing
pkg&amp;gt; add HomotopyContinuation Alternatively, you can also use
import Pkg Pkg.</description>
    </item>
    
    <item>
      <title>Problem formulation</title>
      <link>/guides/input/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/input/</guid>
      <description>In this guide we want to take a deep dive into the modeling language (ModelKit) provided by HomotopyContinuation.jl and also provide some tips along the way on how to best formulate your specific problem. This guide is complementary to the package function documentation where all available functions are described.
Variables We start with the basic building block of every problem: variables. You can construct a variable using the Variable constructor. Let&#39;s start by creating variables x and y.</description>
    </item>
    
    <item>
      <title>How to solve a system of polynomial equations</title>
      <link>/guides/solve-first-system/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/solve-first-system/</guid>
      <description>Requirements If you have not yet installed HomotopyContinuation.jl, please consider the installation guide.
Solve your first system of equations Consider the following simple system of two polynomials in two variables.
$$ f=\begin{bmatrix}x^2+2y \\ y^2-2 \end{bmatrix} $$
Solving the equation $f=0$ can be accomplished as follows
using HomotopyContinuation # load the package into the current Julia session @var x y; # declare the variables x and y f = System([x^2 + 2y, y^2 - 2]) # construct system f result = solve(f) # solve f After the computation has finished, you should see the following output.</description>
    </item>
    
    <item>
      <title>An introduction to the numerical solution of polynomial systems</title>
      <link>/guides/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/introduction/</guid>
      <description>A first example We are interested in the numerical solution of systems of polynomial equations like $$\begin{array}{rl} -x^5y &amp;amp;= (x^4 + y^4 - 1)(x^2 + y^2 - 2) \\ \frac12 &amp;amp;= x^2+2xy^2 - 2y^2 . \end{array}$$
Equivalently, we can see the solutions of this system of equations as the common zero set $V(f_1,f_2)$ of the polynomials $$ f_1(x,y) = (x^4 + y^4 - 1)(x^2 + y^2 - 2) + x^5y \quad \text{ and } \quad f_2(x,y) = x^2+2xy^2 - 2y^2 - \frac12 .</description>
    </item>
    
    <item>
      <title>Systems with parameters</title>
      <link>/guides/parameter-homotopies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/parameter-homotopies/</guid>
      <description>Parameter Homotopies Consider the situation in which one has to solve a specific instance of a parametrized family of polynomial systems
$$ P = \{F(x,p) = (f_1(x,p), \ldots, f_n(x,p)) \mid p \in \mathbb{C}^m\}. $$
To not destroy the solution structure it is desirable to not leave $P$ during the homotopy. This can be accomplished by using the homotopy $$H(x,t) := F(x, (1-t)p + tq)$$ where $p$ and $q$ are parameters in $\mathbb{C}^m$.</description>
    </item>
    
    <item>
      <title>Monodromy</title>
      <link>/guides/monodromy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/monodromy/</guid>
      <description>The monodromy method An alternative to using the solve function is solving a polynomial system $F=(f_1,\ldots,f_n)$ by monodromy. This approach is more efficient, but requires the user to provide at least one solution of $F=0$. Here is the basic idea:
Suppose $x$ is a solution $F(x)=0$ and that $F=F_{u_0}$ is a point in a family of polynomial systems $\mathcal{F}=\{F_u : u\in \mathbb{C}^k\}$ which is defined with $k\geq 1$ parameters. The monodromy method consists in moving around $u$ in a loop starting and ending at $u_0$ while tracking $x$ along that loop.</description>
    </item>
    
    <item>
      <title>Polyhedral homotopy</title>
      <link>/guides/polyhedral/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/polyhedral/</guid>
      <description>Polyhedral start systems Polyhedral is a particular choice of start system for homotopy continuation.
The advantage of so called polyhedral homotopies over total degree homotopies is that the number of paths to track can be significantly smaller for the polyhedral homotopy.
Here is how it works:
julia&amp;gt; using HomotopyContinuation, PolynomialTestSystems julia&amp;gt; f = equations(cyclic(7)) julia&amp;gt; solve(f; start_system = :polyhedral) Result with 924 solutions ================================== • 924 non-singular solutions (56 real) • 0 singular solutions (0 real) • 924 paths tracked • random seed: 606778 For comparison:</description>
    </item>
    
    <item>
      <title>Using HomotopyContinuation.jl from Macaulay2</title>
      <link>/guides/macaulay2/</link>
      <pubDate>Mon, 15 Apr 2019 18:56:55 +0100</pubDate>
      
      <guid>/guides/macaulay2/</guid>
      <description>Macaulay2 is a great software for symbolic computations and it has many features which are not yet available in Julia. In this guide we show a possible workflow where the symbolic computations are happening in Macaulay2 and the numerical work in Julia.
Setting things up Our goal is to have a function writeSystem available which accepts as input an ideal I (or a list of polynomials) and a filename f and generates a file f containing the necessary Julia code to compute the solutions of I using HomotopyContinuation.</description>
    </item>
    
    <item>
      <title>Solving many systems in a loop</title>
      <link>/guides/many-systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/many-systems/</guid>
      <description>Polynomial systems arising in application very often have a coefficients which are determined by some parameters.
We now want to show you how you can setup an efficient way to solve this polynomial system for many parameter values. Assume we have the following polynomial system:
using HomotopyContinuation @var x y z p[1:3] F = System( [ x + 3 + 2y + 2y^2 - p[1], (x - 2 + 5y) * z + 4 - p[2] * z, (x + 2 + 4y) * z + 5 - p[3] * z, ]; parameters = p ) System of length 3 3 variables: x, y, z 3 parameters: p₁, p₂, p₃ 3 - p₁ + x + 2*y + 2*y^2 4 - z*p₂ + z*(-2 + x + 5*y) 5 - z*p₃ + z*(2 + x + 4*y) First, we compute the solutions for generic parameters and then use a parameter homotopy.</description>
    </item>
    
    <item>
      <title>Overdetermined systems</title>
      <link>/guides/overdetermined-tracking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/overdetermined-tracking/</guid>
      <description>Overdetermined systems A system of polynomial equations $f=(f_1(x_1,\ldots, x_m),\ldots, f_n(x_1,\ldots,x_m))$ is called overdetermined, if it has more equations than variables; i.e., when $n&amp;gt;m$. HomotopyContinuation.jl can solve overdetermined systems. Here is a simple example.
$$f(x,y,z) = \begin{bmatrix} xz-y^2 \\ y-z^2 \\ x-yz \\ x + y + z + 1\end{bmatrix}.$$
This system has 4 equation in 3 variables. One might expect that it has no solution, but actually it has solutions, as is explained here.</description>
    </item>
    
    <item>
      <title>Choosing a start system</title>
      <link>/guides/start-systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/start-systems/</guid>
      <description>Choosing a start system for homotopy continuation is an art for itself. We give some basic rules for start systems. They can roughly be subdivided into three classes:
I know nothing about the structure of my polynomial system In this case, there are two options: choosing a totaldegree start system, or a polyhedral start system (the default).
The first one is suitable for system, which are dense. The second one is suitable for systems, which are sparse.</description>
    </item>
    
    <item>
      <title>Composite systems</title>
      <link>/guides/composite/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/composite/</guid>
      <description>If your system of polynomials is given as a composition of several systems, you can exploit this in HomotopyContinuation.jl.
Composition of two systems If $f$ and $g$ are your systems, and you want to solve $f \circ g$, then you can do this by
solve(f ∘ g) For instance, if
$$ f = \begin{bmatrix} ab - 2\\ ac- 1\end{bmatrix}, \quad g = \begin{bmatrix}x + y\\ y + 3\\ x + 2\end{bmatrix},$$</description>
    </item>
    
    <item>
      <title>Data analysis of solutions</title>
      <link>/guides/data-analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/data-analysis/</guid>
      <description>We provide two special functions for analysing data: unique_points and multiplicities. They do the following: suppose that A is an array of real or complex vectors. Then, unique_points(A) filters multiple elements of A, such that each entry appears once (given a provided tolerance). On the other hand, multiplicities(A) returns the indices of multiple elements in A.
Unique points Here is an example:
julia&amp;gt; using HomotopyContinuation julia&amp;gt; A = [[1.0,0.5], [0.99,0.49], [2.</description>
    </item>
    
    <item>
      <title>Solutions in a product of projective spaces</title>
      <link>/guides/multiprojective/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/multiprojective/</guid>
      <description>When your system has a multi-projective structure, you can declare variables groups for accelerating the computations.
Here is a simple example for the following system defined over $\mathbb{CP}^1\times \mathbb{CP}^1$:
$$f(u,y,u,v) = \begin{bmatrix} xy - 6uv\\ x^2 - u^2 \end{bmatrix}.$$
The Julia code for the variable groups ${x,y}$ and ${u,v}$ is as follows.
using HomotopyContinuation @var x y u v f = System([x*y - 6u*v, x^2 - u^2], variable_groups=[[x,u], [y,v]]) System of length 2 4 variables (2 groups): [x, u], [y, v] -6*u*v + x*y -u^2 + x^2 S = solve(f, start_system = :total_degree) Result with 2 solutions ======================= • 2 paths tracked • 2 non-singular solutions (0 real) • random_seed: 0xdf2fbbdb • start_system: :total_degree </description>
    </item>
    
    <item>
      <title>Total Degree Homotopy</title>
      <link>/guides/totaldegree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/guides/totaldegree/</guid>
      <description>Total degree is a particular choice of start system for homotopy continuation.
It is the simplest start system for a system
$$ F(x_1,\ldots,x_n)=\begin{bmatrix} f_1(x_1,\ldots,x_n) \\ \vdots\\ f_n(x_1,\ldots,x_n) \end{bmatrix}. $$
The total degree start system of $F$ is
$$ G(x_1,\ldots,x_n) = \begin{bmatrix} x_1^{d_1} - a_1 \\ \vdots \\ x_n^{d_n} - a_n\end{bmatrix}, \text{ where } d_i = \text{deg}(F_i), $$
and where the $a_i$ are random numbers. There are $d_1\cdots d_n$ many solutions to this system, which are easy to write down.</description>
    </item>
    
  </channel>
</rss>