<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Setting up homotopies · Julia Homotopy Continuation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Julia Homotopy Continuation logo"/></a><h1>Julia Homotopy Continuation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="examples.html">Examples</a></li><li class="current"><a class="toctext" href="Homotopy.html">Setting up homotopies</a><ul class="internal"><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Homotopies-1">Homotopies</a></li><li><a class="toctext" href="#higherlevelconstructs-1">Higher level constructs</a></li><li><a class="toctext" href="#Interface-1">Interface</a></li><li><a class="toctext" href="#Condition-numbers-1">Condition numbers</a></li></ul></li><li><a class="toctext" href="solve.html">Solving homotopies</a></li><li><a class="toctext" href="pathtracker.html">Pathtracking</a></li><li><a class="toctext" href="endgame.html">Endgame</a></li><li><a class="toctext" href="set_up_homotopy.html">How to set up your own homotopy</a></li><li><a class="toctext" href="set_up_pathtracker.html">How to set up your own pathtracking algorithm</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="Homotopy.html">Setting up homotopies</a></li></ul><a class="edit-page" href="https://github.com/JuliaHomotopyContinuation/juliahomotopycontinuation.github.io/blob/source/docs/src/Homotopy.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Setting up homotopies</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Setting-up-homotopies-1" href="#Setting-up-homotopies-1">Setting up homotopies</a></h1><p><code>Homotopies.jl</code> is a package for constructing (polynomial) <a href="https://en.wikipedia.org/wiki/Homotopy">homotopies</a> <span>$H(x,t)$</span>. For the convient use we export in <code>HomotopyContinuation</code> every function from <code>Homotopies</code>.</p><p>Each homotopy has the same <a href="Homotopy.html#Interface-1">Interface</a> so that you can switch easily between different homotopy types. Based on this interface there are also some convenient <a href="Homotopy.html#higherlevelconstructs-1">higher level constructs</a> provided; e.g., the construction of a total degree system and its start solutions.</p><p>Homotopies.jl provides an interface to <a href="https://github.com/JuliaAlgebra/DynamicPolynomials.jl">DynamicPolynomials.jl</a> for human-readable input and output. Most of the examples in this introduction are written with <a href="https://github.com/JuliaAlgebra/DynamicPolynomials.jl">DynamicPolynomials.jl</a> . Internally, <code>Homotopies.jl</code> uses <a href="https://github.com/JuliaAlgebra/FixedPolynomials.jl">FixedPolynomials.jl</a> for fast evaluation.</p><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>As an example we construct a homotopy between the polynomial systems</p><div>\[f= \begin{bmatrix} x + y^3\\  x^2y-2y\end{bmatrix},\quad  
g= \begin{bmatrix}x^3+2\\ y^3+2\end{bmatrix}.\]</div><p>Currently, there are two types of <a href="Homotopy.html#Homotopies-1">homotopies</a> implemented:</p><pre><code class="language-julia">StraightLineHomotopy
GeodesicOnTheSphere</code></pre><p>The code to initialize a StraightLineHomotopy is as follows.</p><pre><code class="language-julia">using HomotopyContinuation
import DynamicPolynomials: @polyvar # @polyvar is a function for initializing variables.
@polyvar x y # initilize the variables x y

f = [x + y^3, x^2*y-2y]
g = [x^3+2, y^3+2]

H = StraightLineHomotopy(f, g) # H is now StraightLineHomotopy{Int64}

# to avoid unnecessary conversions one could also have
H = StraightLineHomotopy{Complex128}([x + y^3, x^2*y-2y], [x^3+2, y^3+2])

# we can now evaluate H
evaluate(H, rand(Complex128, 2), 0.42)
# or alternatively
H(rand(Complex128, 2), 0.42)</code></pre><h2><a class="nav-anchor" id="Homotopies-1" href="#Homotopies-1">Homotopies</a></h2><p>The following homotopies are implemented. They are subtypes of <code>AbstractPolynomialHomotopy</code></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.StraightLineHomotopy" href="#Homotopies.StraightLineHomotopy"><code>Homotopies.StraightLineHomotopy</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">StraightLineHomotopy(start, target)</code></pre><p>Construct the homotopy <code>t * start + (1-t) * target</code>.</p><p><code>start</code> and <code>target</code> have to match and to be one of the following</p><ul><li><p><code>Vector{&lt;:MP.AbstractPolynomial}</code> where <code>MP</code> is <a href="https://github.com/blegat/MultivariatePolynomials.jl"><code>MultivariatePolynomials</code></a></p></li><li><p><code>MP.AbstractPolynomial</code></p></li><li><p><code>Vector{&lt;:FP.Polynomial}</code> where <code>FP</code> is <a href="https://github.com/saschatimme/FixedPolynomials.jl"><code>FixedPolynomials</code></a></p></li></ul><pre><code class="language-none">StraightLineHomotopy{T}(start, target)</code></pre><p>You can also force a specific coefficient type <code>T</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/homotopies/straightline.jl#L3-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.GeodesicOnTheSphere" href="#Homotopies.GeodesicOnTheSphere"><code>Homotopies.GeodesicOnTheSphere</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GeodesicOnTheSphere(start, target)</code></pre><p>Homotopy is the geodesic from <code>g=start/|start|</code> (t=1) to <code>f=target/|target|</code> (t=0):</p><p><code>H(x,t) = (cos(tα) - sin (tα)cos(α)/sin(α)) f + sin(tα) / sin(α) * g</code></p><p>where <span>$α = cos |&lt;f,g&gt;|$</span>. The constructor automatically homgenizes <code>start</code> and <code>target</code>.</p><p><code>start</code> and <code>target</code> have to match and to be one of the following</p><ul><li><p><code>Vector{&lt;:MP.AbstractPolynomial}</code> where <code>MP</code> is <a href="https://github.com/blegat/MultivariatePolynomials.jl"><code>MultivariatePolynomials</code></a></p></li><li><p><code>MP.AbstractPolynomial</code></p></li><li><p><code>Vector{&lt;:FP.Polynomial}</code> where <code>FP</code> is <a href="https://github.com/saschatimme/FixedPolynomials.jl"><code>FixedPolynomials</code></a></p></li></ul><pre><code class="language-none">GeodesicOnTheSphere{T}(start, target)</code></pre><p>You can also force a specific coefficient type <code>T</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/homotopies/geodesic_on_the_sphere.jl#L3-L21">source</a></section><h2><a class="nav-anchor" id="higherlevelconstructs-1" href="#higherlevelconstructs-1">Higher level constructs</a></h2><h3><a class="nav-anchor" id="totaldegree-1" href="#totaldegree-1">Total degree homotopy</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.totaldegree" href="#Homotopies.totaldegree"><code>Homotopies.totaldegree</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">totaldegree(H::Type{AbstractPolynomialHomotopy}, F, [unitroots=false])</code></pre><p>Construct a  total degree homotopy of type <code>H</code> with <code>F</code> and an iterator of its solutions. This is the homotopy with start system</p><div>\[\begin{align*}
    z_1^{d_1} &amp;- b_1\\
    z_1^{d_2} &amp;- b_2\\
    &amp;\vdots \\
    z_n^{d_n} &amp;- b_n\\
\end{align*}\]</div><p>and target system <code>F</code>, where <span>$d_i$</span> is the degree of the <span>$i$</span>-th polynomial of <code>F</code>. If <code>unitroots=true</code> then <span>$b_i=1$</span> otherwise <span>$b_i$</span> is a random complex number (with real and imaginary part in the unit interval).</p><p><strong>Example</strong></p><pre><code class="language-julia">H, startsolutions = totaldegree(StraightLineHomotopy{Complex128}, [x^2+y+1, x^3*y-2])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/totaldegree.jl#L43-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.TotalDegreeSolutionIterator" href="#Homotopies.TotalDegreeSolutionIterator"><code>Homotopies.TotalDegreeSolutionIterator</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TotalDegreeSolutionIterator(degrees, b)</code></pre><p>Given the <code>Vector</code>s <code>degrees</code> and <code>b</code> <code>TotalDegreeSolutionIterator</code> enumerates all solutions of the system</p><div>\[\begin{align*}
    z_1^{d_1} - b_1 &amp;= 0 \\
    z_1^{d_2} - b_2 &amp;= 0 \\
    &amp;\vdots \\
    z_n^{d_n} - b_n &amp;= 0 \\
\end{align*}\]</div><p>where <span>$d_i$</span> is <code>degrees[i]</code> and <span>$b_i$</span> is <code>b[i]</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/totaldegree.jl#L3-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.totaldegree_startsystem" href="#Homotopies.totaldegree_startsystem"><code>Homotopies.totaldegree_startsystem</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">totaldegree_startsystem(F::Vector{FP.Polynomial{&lt;:Complex}}, [unit_roots=false])</code></pre><p>Return the system</p><div>\[\begin{align*}
    z_1^{d_1} &amp;- b_1\\
    z_1^{d_2} &amp;- b_2\\
    &amp;\vdots \\
    z_n^{d_n} &amp;- b_n\\
\end{align*}\]</div><p>where <span>$d_i$</span> is the degree of the <span>$i$</span>-th polynomial of <code>F</code> and an iterator of its solutions. If <code>unitroots=true</code> then <span>$b_i=1$</span> otherwise <span>$b_i$</span> is a random complex number (with real and imaginary part in the unit interval).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/totaldegree.jl#L80-L96">source</a></section><h3><a class="nav-anchor" id="Random-homotopies-1" href="#Random-homotopies-1">Random homotopies</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.randomhomotopy" href="#Homotopies.randomhomotopy"><code>Homotopies.randomhomotopy</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">randomhomotopy(::Type{AbstractPolynomialHomotopy{T}}, size::Int; kwargs...)</code></pre><p>Create a total degree homotopy where the target system is a <a href="Homotopy.html#Homotopies.randomsystem"><code>randomsystem(T, size, size; kwargs...)</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; H, solutions = randomhomotopy(StraightLineHomotopy{Complex128}, 2, mindegree=3, maxdegree=6);
julia&gt; length(H)
3
julia&gt; nvariables(H)
3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/randomhomotopy.jl#L3-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.randomsystem" href="#Homotopies.randomsystem"><code>Homotopies.randomsystem</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">randomsystem([T=Complex128,] nequations::Int, nvars::Int; mindegree=0, maxdegree=5, rng=Base.Random.GLOBAL_RNG, density=rand() * 0.8 + 0.1)</code></pre><p>Creates a random polynomial system of <code>nequations</code> equations with <code>nvars</code> variables (named <span>$x_1$</span>, ...<span>$x_{nvars}$</span>). Each polynomial has a total degree uniformly drawn from <span>$[mindegree, maxdegree]$</span>. The coefficients are drawn independently from the given <code>rng</code>. With <code>density</code> you can control how many coefficients are non-zero. A value of <code>1.0</code> creates a dense polynomial (i.e. every coefficient is non-zero). A value of <code>0.5</code> creates a polynomial where only half of all monomials are non zero.</p><pre><code class="language-none">randomsystem([T=Complex128,] degrees::Vector{Int}, variables::Vector{Symbol}; rng=N(0,1))</code></pre><p>Create a random polynomial system with the given <code>degrees</code> and <code>variables</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/randomhomotopy.jl#L26-L39">source</a></section><h2><a class="nav-anchor" id="Interface-1" href="#Interface-1">Interface</a></h2><h3><a class="nav-anchor" id="Evaluation-1" href="#Evaluation-1">Evaluation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.evaluate" href="#Homotopies.evaluate"><code>Homotopies.evaluate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">evaluate(H::AbstractPolynomialHomotopy, x, t)</code></pre><p>Evaluate the homotopy <code>H</code> at <code>x</code> to time <code>t</code>, i.e. <span>$H(x,t)$</span>.</p><pre><code class="language-none">evaluate(H::AbstractPolynomialHomotopy, x, t, cfg::PolynomialHomotopyConfig)</code></pre><p>Evaluate the homotopy <code>H</code> at <code>x</code> to time <code>t</code> using the precompuated values in <code>cfg</code>. Note that this is significantly faster than <code>evaluate(H, x, t)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/interface.jl#L4-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.evaluate!" href="#Homotopies.evaluate!"><code>Homotopies.evaluate!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">evaluate!(u::Vector, H::AbstractPolynomialHomotopy, x, t)</code></pre><p>Evaluate the homotopy <code>H</code> at <code>x</code> to time <code>t</code>, i.e. <span>$H(x,t)$</span>, and store the result in <code>u</code>.</p><pre><code class="language-none">evaluate!(u::AbstractVector, H::AbstractPolynomialHomotopy, x, t, cfg::PolynomialHomotopyConfig)</code></pre><p>Evaluate the homotopy <code>H</code> at <code>x</code> to time <code>t</code> using the precompuated values in <code>cfg</code> and store the result in <code>u</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/interface.jl#L16-L25">source</a></section><h3><a class="nav-anchor" id="Differentiation-1" href="#Differentiation-1">Differentiation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.jacobian" href="#Homotopies.jacobian"><code>Homotopies.jacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">jacobian(H::AbstractPolynomialHomotopy, x, t, cfg::PolynomialHomotopyConfig)</code></pre><p>Compute the jacobian of <code>H</code> at <code>x</code> and <code>t</code> using the precomputed values in <code>cfg</code>. The jacobian is constructed w.r.t. <code>x</code>, i.e. it doesn&#39;t contain the partial derivatives w.r.t. <code>t</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/interface.jl#L37-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.jacobian!" href="#Homotopies.jacobian!"><code>Homotopies.jacobian!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">jacobian!(u, H::AbstractPolynomialHomotopy, x, t, cfg::PolynomialHomotopyConfig)</code></pre><p>Compute the jacobian of <code>H</code> at <code>x</code> and <code>t</code> using the precomputed values in <code>cfg</code> and store the result in <code>u</code>.</p><pre><code class="language-none">jacobian!(r::JacobianDiffResult, H::AbstractPolynomialHomotopy, x, t, cfg::PolynomialHomotopyConfig)</code></pre><p>Compute <span>$H(x, t)$</span> and the jacobian of <code>H</code> at <code>x</code> and <code>t</code> at once using the precomputated values in <code>cfg</code> and store thre result in <code>r</code>. This is faster than computing both values separetely.</p><p><strong>Example</strong></p><pre><code class="language-julia">cfg = PolynomialHomotopyConfig(H)
r = JacobianDiffResult(cfg)
jacobian!(r, H, x, t, cfg)

value(r) == H(x, t)
jacobian(r) == jacobian(H, x, t, cfg)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/interface.jl#L46-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.dt" href="#Homotopies.dt"><code>Homotopies.dt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dt(H::AbstractPolynomialHomotopy, x, t, cfg::PolynomialHomotopyConfig)</code></pre><p>Compute the derivative of <code>H</code> w.r.t. <span>$t$</span> at <code>x</code> and <code>t</code> using the precomputed values in <code>cfg</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/interface.jl#L69-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.dt!" href="#Homotopies.dt!"><code>Homotopies.dt!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dt!(u, H::AbstractPolynomialHomotopy, x, t, cfg::PolynomialHomotopyConfig)</code></pre><p>Compute the derivative of <code>H</code> w.r.t. <span>$t$</span> at <code>x</code> and <code>t</code> using the precomputed values in <code>cfg</code> and store the result in <code>u</code>.</p><pre><code class="language-none">dt!(r::DtDiffResult, H::AbstractPolynomialHomotopy, x, t, cfg::PolynomialHomotopyConfig)</code></pre><p>Compute the derivative of <code>H</code> w.r.t. <span>$t$</span> at <code>x</code> and <code>t</code> using the precomputed values in <code>cfg</code> and store the result in <code>r</code>. This is faster than computing both values separetely.</p><p><strong>Example</strong></p><pre><code class="language-julia">cfg = PolynomialHomotopyConfig(H)
r = DtDiffResult(cfg)
dt!(r, H, x, t, cfg)

value(r) == H(x, t)
dt(r) == dt(H, x, t, cfg)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/interface.jl#L76-L96">source</a></section><h3><a class="nav-anchor" id="Homogenization-1" href="#Homogenization-1">Homogenization</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.homogenize" href="#Homotopies.homogenize"><code>Homotopies.homogenize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">homogenize(H::AbstractPolynomialHomotopy)</code></pre><p>Homogenize the homotopy <code>H</code>. This adds an additional variable. If <code>H</code> is already homogenized, this is the identity.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/interface.jl#L107-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.dehomogenize" href="#Homotopies.dehomogenize"><code>Homotopies.dehomogenize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dehomogenize(H::AbstractPolynomialHomotopy)</code></pre><p>Dehomogenize the homotopy <code>H</code>. This removes the first variable. If <code>H</code> is not homogenized, this is the identity.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/interface.jl#L115-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.ishomogenized" href="#Homotopies.ishomogenized"><code>Homotopies.ishomogenized</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ishomogenized(H::AbstractPolynomialHomotopy)</code></pre><p>Check whether the homotopy <code>H</code> was homogenized.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/interface.jl#L123-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.ishomogenous" href="#Homotopies.ishomogenous"><code>Homotopies.ishomogenous</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ishomogenous(H::AbstractPolynomialHomotopy)</code></pre><p>Check whether the homotopy <code>H</code> is homogenous. This does not imply that <code>H</code> was homogenized.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/interface.jl#L130-L134">source</a></section><h3><a class="nav-anchor" id="Misc-1" href="#Misc-1">Misc</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.nvariables" href="#Homotopies.nvariables"><code>Homotopies.nvariables</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nvariables(H::AbstractPolynomialHomotopy)</code></pre><p>The number of variables which <code>H</code> expects as input, i.e. to evaluate <code>H(x,t)</code> <code>x</code> has to be a vector of length <code>nvariables(H)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/interface.jl#L99-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.weylnorm" href="#Homotopies.weylnorm"><code>Homotopies.weylnorm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">weylnorm(H::AbstractPolynomialHomotopy)</code></pre><p>Creates a function with variable <code>t</code> that computes the Weyl norm (or Bombieri norm) of <span>$H(x,t)$</span>. See <a href="https://en.wikipedia.org/wiki/Bombieri_norm">here</a> for details about the Weyl norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/interface.jl#L29-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.gammatrick!" href="#Homotopies.gammatrick!"><code>Homotopies.gammatrick!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gammatrick!(H::AbstractPolynomialHomotopy{Complex} [, seed::Int]])</code></pre><p>Scale the coefficients of the start system of <code>H</code> with a random complex number picked uniformly from the (complex) unit circle. Use this to make the paths <span>$z(t)$</span> generic.</p><pre><code class="language-none">gammatrick!(H::AbstractPolynomialHomotopy{Complex}, γ::Complex)</code></pre><p>You can also pass a scaling factor directly.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/polynomial.jl#L45-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.gammatrick" href="#Homotopies.gammatrick"><code>Homotopies.gammatrick</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gammatrick(H::AbstractPolynomialHomotopy{Complex} , γ::Number)</code></pre><p>Scale the coefficients of the start system of <code>H</code> with <code>γ</code>.</p><pre><code class="language-none">gammatrick(H::AbstractPolynomialHomotopy{Complex})</code></pre><p>A a random complex number <code>γ</code> is picked uniformly from the (complex) unit circle and then scale the coefficients of the start system of <code>H</code> with <code>γ</code>. This returns the new <code>H</code> and <code>γ</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/polynomial.jl#L62-L72">source</a></section><h2><a class="nav-anchor" id="Condition-numbers-1" href="#Condition-numbers-1">Condition numbers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.κ" href="#Homotopies.κ"><code>Homotopies.κ</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">κ(H, z, t, cfg)</code></pre><p>Computes the condition number of H at (z, t) (with config cfg). See Condition^[1] for details</p><p>Proposition 16.10: κ(f,z) := ‖f‖ ‖ Df(z)^† diag(‖ z ‖^{d_i-1}) ‖</p><p>[1]: Condition, Bürgisser and Cucker</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/condition.jl#L4-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.κ_norm" href="#Homotopies.κ_norm"><code>Homotopies.κ_norm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">κ_norm(H, z, t, cfg)</code></pre><p>Computes the condition number of H at (z, t) (with config cfg). See Condition^[1] for details</p><p>Eq. (16.11): κ_norm(f,z) := ‖f‖ ‖ Df(z)^† diag(√{d_i}‖ z ‖^{d_i-1}) ‖</p><p>[1]: Condition, Bürgisser and Cucker</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/condition.jl#L39-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homotopies.μ_norm" href="#Homotopies.μ_norm"><code>Homotopies.μ_norm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">μ_norm(H, z, t, cfg)</code></pre><p>Computes the condition number of H at (z, t) (with config cfg). See Condition^[1] for details</p><p>Definition 16.43: μ_norm(f,z) := ‖f‖ ‖ (Df(z)-(T_z))^{-1} diag(√{d_i}‖ z ‖^{d_i-1}) ‖</p><p>[1]: Condition, Bürgisser and Cucker</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaHomotopyContinuation/Homotopies.jl/blob/74e0f56da5b9b8a04551ca105fed95407794dfdf/src/condition.jl#L67-L75">source</a></section><footer><hr/><a class="previous" href="examples.html"><span class="direction">Previous</span><span class="title">Examples</span></a><a class="next" href="solve.html"><span class="direction">Next</span><span class="title">Solving homotopies</span></a></footer></article></body></html>
