<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Julia Homotopy Continuation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Julia Homotopy Continuation logo"/></a><h1>Julia Homotopy Continuation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="examples.html">Examples</a><ul class="internal"><li><a class="toctext" href="#Computing-the-degree-of-a-variety-1">Computing the degree of a variety</a></li><li><a class="toctext" href="#Using-different-types-of-homotopies-1">Using different types of homotopies</a></li><li><a class="toctext" href="#Using-different-types-of-pathrackers-1">Using different types of pathrackers</a></li><li><a class="toctext" href="#R-Serial-Link-Robots-1">6-R Serial-Link Robots</a></li></ul></li><li><a class="toctext" href="Homotopy.html">Setting up homotopies with Homotopy.jl</a></li><li><a class="toctext" href="solve.html">Solving homotopies</a></li><li><a class="toctext" href="pathtracker.html">Pathtracking</a></li><li><a class="toctext" href="endgame.html">Endgame</a></li><li><a class="toctext" href="set_up_homotopy.html">How to set up your own homotopy</a></li><li><a class="toctext" href="set_up_pathtracker.html">How to set up your own pathtracking algorithm</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="examples.html">Examples</a></li></ul><a class="edit-page" href="https://github.com/JuliaHomotopyContinuation/juliahomotopycontinuation.github.io/blob/source/docs/src/examples.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Examples</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="examples-1" href="#examples-1">Examples</a></h1><h2><a class="nav-anchor" id="Computing-the-degree-of-a-variety-1" href="#Computing-the-degree-of-a-variety-1">Computing the degree of a variety</a></h2><p>Consider the projective variety in the 2-dimensional complex projective space <span>$CP^2$</span>.</p><div>\[V = \{ x^2 + y^2 - z^2 = 0 \}\]</div><p>The degree of <span>$V$</span> is the number of intersection points of <span>$V$</span> with a generic line.   Let us see what it is. First we initialize the defining equation of <span>$V$</span>.</p><pre><code class="language-julia">import DynamicPolynomials: @polyvar

@polyvar x y z
f = x^2 + y^2 - z^2</code></pre><p>Let us sample the equation of a random line.</p><pre><code class="language-julia">L = randn(1,3) * [x; y; z]</code></pre><p>Now we compute the number of solutions to <span>$[f=0, L=0]$</span>.</p><pre><code class="language-julia">using HomotopyContinuation
solve([f; L])</code></pre><p>We find two distinct solutions and conclude that the degree of <span>$V$</span> is 2.</p><h2><a class="nav-anchor" id="Using-different-types-of-homotopies-1" href="#Using-different-types-of-homotopies-1">Using different types of homotopies</a></h2><p>the following example is from section 7.3 of [The numerical solution of systems of polynomials, Sommese, Wampler].</p><p>Consider a triangle with sides a,b,c and let θ be the angle opposite of c. The goal is to compute θ from a,b,c. We define sθ := sin θ and cθ := cos θ. The polynomial corresponding system is.</p><pre><code class="language-julia">import DynamicPolynomials: @polyvar

a = 5
b = 4
c = 3

@polyvar sθ cθ
f = [cθ^2 + sθ^2 - 1, (a * cθ - b)^2 + (a * sθ)^2 - c^2]</code></pre><p>To set up a <a href="Homotopy.html#totaldegree-1">totaldegree</a> homotopy of type StraightLineHomotopy we have to write</p><pre><code class="language-julia">using HomotopyContinuation
H, s = totaldegree(StraightLineHomotopy, f)</code></pre><p>This sets up a homotopy <code>H</code> of the specified type using a random starting system that comes with a vector <code>s</code> of solutions. To solve for f = 0 we execute</p><pre><code class="language-julia">solve(H, s)</code></pre><p>If instead we wanted to use GeodesicOnTheSphere as homotopy type, we write</p><pre><code class="language-julia">H, s = totaldegree(GeodesicOnTheSphere, f)
solve(H, s)</code></pre><p>The angles are of course only the real solutions of f = 0. We get them by using</p><pre><code class="language-julia">solution(ans, only_real=true)</code></pre><h2><a class="nav-anchor" id="Using-different-types-of-pathrackers-1" href="#Using-different-types-of-pathrackers-1">Using different types of pathrackers</a></h2><p>The following polynomial system is what is called a binding polynomial in chemistry.</p><pre><code class="language-julia">import DynamicPolynomials: @polyvar

@polyvar w1 w2 w3 w4 w5 w6

f = [11*(2*w1+3*w3+5*w5)+13*(2*w2+3*w4+5*w6),
    11*(6*w1*w3+10*w1*w5+15*w3*w5)+13*(6*w2*w4+10*w2*w6+15*w4*w6),
    330*w1*w3*w5+390*w2*w4*w6,
    143*(2*w1*w2+3*w3*w4+5*w5*w6),
    143*(6*w1*w2*w3*w4+10*w1*w2*w5*w6+15*w3*w4*w5*w6),
    4290*w1*w2*w3*w4*w5*w6]</code></pre><p>Suppose we wanted to solve <span>$f(w)=a$</span>, where</p><pre><code class="language-julia">a=[71, 73, 79, 101, 103, 107]</code></pre><p>To get an initial solution we compute a random forward solution with <code>FixedPolynomials.jl</code>. We use <code>Julia&#39;s</code> <code>convert</code> function to convert <span>$f$</span> into the correct type. Then, we use the <code></code> <code>evaluate</code> command from <code>FixedPolynomials.jl</code>.</p><pre><code class="language-julia">const FP = FixedPolynomials
w_0 = vec(randn(6,1))
a_0 = FP.evaluate(convert(Vector{FixedPolynomials.Polynomial{Float64}}, f), w_0)</code></pre><p>Now we set up the homotopy.</p><pre><code class="language-julia">H = StraightLineHomotopy(f-a_0, f-a)</code></pre><p>and compute a backward solution with starting value <span>$w_0$</span> by</p><pre><code class="language-julia">solve(H, w_0)</code></pre><p>By default the <code>solve</code> function uses <code>SphericalPredictorCorrector</code> as the pathtracking routing. To use the <code>AffinePredictorCorrector</code> instead we must write</p><pre><code class="language-julia">solve(H, w_0, AffinePredictorCorrector())</code></pre><h2><a class="nav-anchor" id="R-Serial-Link-Robots-1" href="#R-Serial-Link-Robots-1">6-R Serial-Link Robots</a></h2><p>The following example is from section 9.4 of</p><p>[The numerical solution of systems of polynomials, Sommese, Wampler].</p><p>Consider a robot that consists of 7 links connected by 6 joints. The first link is fixed on the ground. Let us denote by <span>$z_1,...,z_6$</span> the unit vectors that point in the direction of the joint axes.  They satisfy the following polynomial equations</p><div>\[z_i ⋅ z_i = 1\\

z_i ⋅ z_{i+1} = \cos α_i\\

a_1 * z_1 × z_2 + ... + a_5 * z_5 × z_6 + a_6 * z_2 + ... + a_9 * z_5 = p\]</div><p>for some <span>$(α,a)$</span> and a known <span>$p$</span> (see the aforementioned reference for a detailed explanation on how these numbers are to be interpreted).</p><p>The forward problem consists of computing <span>$(α,a)$</span> given the <span>$z_i$</span> and <span>$p$</span>. The backward problem consists of computing  <span>$z_i$</span> that realize some fixed <span>$(α,a)$</span>.</p><p>We now compute first a forward solution <span>$(α_0, a_0)$</span>, and then use <span>$(α_0, a_0)$</span> to compute a backward solution for the problem imposed by some random <span>$(α, a)$</span>.</p><pre><code class="language-julia">using HomotopyContinuation
import DynamicPolynomials: @polyvar

@polyvar z2[1:3] z3[1:3] z4[1:3] z5[1:3]
z1 = [1, 0, 0]
z6 = [1, 0, 0]
p = [1, 1, 0]
z = [z1, z2, z3, z4, z5, z6]

f = [z[i] ⋅ z[i] for i=2:5]
g = [z[i] ⋅ z[i+1] for i=1:5]
h = hcat([[z[i] × z[i+1] for i=1:5]; [z[i] for i=2:5]]...)

α = randexp(5)
a = randexp(9)</code></pre><p>Let us compute a random forward solution.</p><pre><code class="language-julia">z_0=rand(3,4); # Compute a random assignment for the variable z
for i = 1:4
    z_0[:,i] = z_0[:,i]./ norm(z_0[:,i]) # normalize the columns of z_0 to norm 1
end</code></pre><p>We want to compute the angles <span>$g(z_0)$</span> with <code>FixedPolynomials.jl</code>. We use <code>Julia&#39;s</code> <code>convert</code> function to convert <span>$g$</span> into the correct type. Then, we use the <code></code> <code>evaluate</code> command from <code>FixedPolynomials.jl</code>.</p><pre><code class="language-julia">import FixedPolynomials: evaluate
const FP = FixedPolynomials

z_0 = vec(z_0) # vectorize z_0, because the evaluate function takes vectors as input

# compute the forward solution of α
α_0 = acos.( FP.evaluate(convert(Vector{FixedPolynomials.Polynomial{Float64}}, g), z_0) )

# evaluate h at z_0
h_0 = FP.evaluate(convert(Vector{FixedPolynomials.Polynomial{Float64}}, vec(h)), z_0)
# compute a solution to h(z_0) * a = p
h_0 = reshape(h_0,3,9)
a_0 = h_0\p</code></pre><p>Now we have forward solutions <span>$α_0$</span> and <span>$a_0$</span>. From this we construct the following StraightLineHomotopy.</p><pre><code class="language-julia">H = StraightLineHomotopy([f-1; g-cos.(α_0); h*a_0-p], [f-1; g-cos.(α); h*a-p])</code></pre><p>To compute a backward solution with starting value <span>$z_0$</span> we finally execute</p><pre><code class="language-julia">solve(H, z_0)</code></pre><p>To compute all the backward solutions we may perform a totaldegree homotopy. Although the Bezout number of the system is 1024 the generic number of solutions is 16. We find all 16 solutions by</p><pre><code class="language-julia">H, s = totaldegree(StraightLineHomotopy, [f-1; g-cos.(α_0); h*a_0-p])
solutions(solve(H, s), singular=false)</code></pre><p>On a MacBook Pro with 2,6 GHz Intel Core i7 and 16 GB RAM memory the above operation takes about 572 seconds. With parallel computing provided by the <code>addprocs()</code> command in <code>Julia</code> it takes about 93 seconds.</p><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="Homotopy.html"><span class="direction">Next</span><span class="title">Setting up homotopies with Homotopy.jl</span></a></footer></article></body></html>
