<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Julia Homotopy Continuation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Julia Homotopy Continuation logo"/></a><h1>Julia Homotopy Continuation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="examples.html">Examples</a><ul class="internal"><li><a class="toctext" href="#Computing-the-degree-of-a-variety-1">Computing the degree of a variety</a></li><li><a class="toctext" href="#Using-different-types-of-homotopies-1">Using different types of homotopies</a></li><li><a class="toctext" href="#The-6R-Robot-1">The 6R Robot</a></li></ul></li><li><a class="toctext" href="Homotopy.html">Setting up homotopies with Homotopy.jl</a></li><li><a class="toctext" href="solve.html">Solving homotopies</a></li><li><a class="toctext" href="pathtracker.html">Pathtracking</a></li><li><a class="toctext" href="endgame.html">Endgame</a></li><li><a class="toctext" href="set_up_homotopy.html">How to set up your own homotopy</a></li><li><a class="toctext" href="set_up_pathtracker.html">How to set up your own pathtracker</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="examples.html">Examples</a></li></ul><a class="edit-page" href="https://github.com/JuliaHomotopyContinuation/juliahomotopycontinuation.github.io/blob/source/docs/src/examples.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Examples</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="examples-1" href="#examples-1">Examples</a></h1><h2><a class="nav-anchor" id="Computing-the-degree-of-a-variety-1" href="#Computing-the-degree-of-a-variety-1">Computing the degree of a variety</a></h2><p>Consider the projective variety in the 2-dimensional complex projective space <span>$CP^2$</span>.</p><pre><code class="language-none">V = { x^2 + y^2 - z^2 = 0 }</code></pre><p>The degree of <span>$V$</span> is the number of intersection points of <span>$V$</span> with a generic line.   Let us see what it is. First we initialize the defining equation of <span>$V$</span>.</p><pre><code class="language-julia">using HomotopyContinuation
import DynamicPolynomials: @polyvar

@polyvar x y z
f = x^2 + y^2 - z^2</code></pre><p>Let us sample the equation of a random line.</p><pre><code class="language-julia">L = randn(1,3) * [x; y; z]</code></pre><p>Now we compute the number of solutions to <span>$[f=0, L=0]$</span>.</p><pre><code class="language-julia">solve([f; L])</code></pre><p>We find two distinct solutions and conclude that the degree of <span>$V$</span> is 2.</p><h2><a class="nav-anchor" id="Using-different-types-of-homotopies-1" href="#Using-different-types-of-homotopies-1">Using different types of homotopies</a></h2><p>In this example we compute the angles sθ, cθ of the triangle with sides of length 3, 4 and 5. The corresponding system is.</p><pre><code class="language-julia">using HomotopyContinuation
import DynamicPolynomials: @polyvar

a = 5
b = 4
c = 3

@polyvar sθ cθ
f = [cθ^2 + sθ^2 - 1, (a * cθ - b)^2 + (a * sθ)^2 - c^2]</code></pre><p>To set up a totaldegree homotopy of type StraightLineHomotopy we have to write</p><pre><code class="language-julia">H, s = totaldegree(StraightLineHomotopy, f)</code></pre><p>The command <code>totaldegree</code> sets up a homotopy <code>H</code> of the specified type using a random starting system that comes with a vector <code>s</code> of solutions. To solve for f = 0 we execute</p><pre><code class="language-julia">solve(H, s)</code></pre><p>If instead we wanted to use GeodesicOnTheSphere as homotopy type, we write</p><pre><code class="language-julia">H, s = totaldegree(GeodesicOnTheSphere, f)
solve(H, s)</code></pre><p>The angles are of course only the real solutions of f = 0. We get them by using</p><pre><code class="language-julia">solution(ans, success=true, at_infinity=true, only_real=true, singular=true)</code></pre><h2><a class="nav-anchor" id="The-6R-Robot-1" href="#The-6R-Robot-1">The 6R Robot</a></h2><pre><code class="language-julia">using HomotopyContinuation
import DynamicPolynomials: @polyvar

@polyvar z2[1:3] z3[1:3] z4[1:3] z5[1:3]
z1 = [1, 0, 0]
z6 = [1, 0, 0]
z = [z1, z2, z3, z4, z5, z6]

f = [z[i] ⋅ z[i] for i=2:5]
g = [z[i] ⋅ z[i+1] for i=1:5]
h = vec(hcat([[z[i] × z[i+1] for i=1:5]; [z[i] for i=2:5]]...))

α = randexp(5)
a = randexp(9)</code></pre><p>Let us compute a random forward solution.</p><pre><code class="language-julia">z_0=rand(3,4); # Compute a random assignment for the variable z
for i = 1:4
    z_0[:,i] = z_0[:,i]./ norm(z_0[:,i]) # normalize the columns of z_0 to norm 1
end</code></pre><p>We want to compute the angles <span>$g(z_0)$</span> with <code>FixedPolynomials.jl</code>. We use <code>Julia&#39;s</code> <code>convert</code> function to convert <span>$g$</span> into the correct type. Then, we use the <code></code> <code>evaluate</code> command from <code>FixedPolynomials.jl</code>.</p><pre><code class="language-julia">import FixedPolynomials: evaluate
const FP = FixedPolynomials

z_0 = vec(z_0) # vectorize z_0, because the evaluate function takes vectors as input

# compute the forward solution of α
α_0 = FP.evaluate(convert(Vector{FixedPolynomials.Polynomial{Float64}}, g), z_0)

# evaluate h at z_0
h_0 = FP.evaluate(convert(Vector{FixedPolynomials.Polynomial{Float64}}, h), z_0)
# compute a solution to h(z_0) * a = 0
h_0 = reshape(h_0,3,9)
a_0 = nullspace(h_0)[:,1]</code></pre><p>Now we have forward solutions <span>$α_0$</span> and <span>$a_0$</span>. From this we construct the following StraightLineHomotopy.</p><pre><code class="language-julia">H = StraightLineHomotopy([f-1; g-α_0; h*a_0], [f-1; g-α; h*a])</code></pre><p>To compute a backward solution with starting value <span>$z_0$</span> we finally execute</p><pre><code class="language-julia">solve(H,z_0)</code></pre><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="Homotopy.html"><span class="direction">Next</span><span class="title">Setting up homotopies with Homotopy.jl</span></a></footer></article></body></html>
